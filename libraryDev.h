#pragma config(Sensor, dgtl11, pneu,           sensorDigitalOut)
#pragma config(Sensor, dgtl12, pneu2,          sensorDigitalOut)
#pragma config(Motor,  port2,           y2,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           x1,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           slide,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           x2,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           y1,            tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Functions that are used in both teleop and anonymous mode

#include "JoystickDriver.c"

// Joystick naming
#define driver1LStickX vexRT[Ch4]
#define driver1LStickY vexRT[Ch3]
#define driver1RStickX vexRT[Ch1]
#define driver1RStickY vexRT[Ch2]

#define driver2LStickX vexRT[Ch4Xmtr2]
#define driver2LStickY vexRT[Ch3Xmtr2]
#define driver2RStickX vexRT[Ch1Xmtr2]
#define driver2RStickY vexRT[Ch2Xmtr2]

// Button naming

// TODO: Test
#define driver1HL vexRT[Btn7L]
#define driver1HU vexRT[Btn7U]
#define driver1HR vexRT[Btn7R]
#define driver1HD vexRT[Btn7D]

#define driver1A vexRT[Btn8L]
#define driver1B vexRT[Btn8U]
#define driver1Y vexRT[Btn8R]
#define driver1X vexRT[Btn8D]

#define driver2HL vexRT[Btn7LXmtr2]
#define driver2HU vexRT[Btn7UXmtr2]
#define driver2HR vexRT[Btn7RXmtr2]
#define driver2HD vexRT[Btn7DXmtr2]

#define driver2A vexRT[Btn8LXmtr2]
#define driver2B vexRT[Btn8UXmtr2]
#define driver2Y vexRT[Btn8RXmtr2]
#define driver2X vexRT[Btn8DXmtr2]

#define driver1L1 vexRT[Btn5U]
#define driver1L2 vexRT[Btn5D]
#define driver1R1 vexRT[Btn6U]
#define driver1R2 vexRT[Btn6D]

#define driver2L1 vexRT[Btn5UXmtr2]
#define driver2L2 vexRT[Btn5DXmtr2]
#define driver2R1 vexRT[Btn6LXmtr2]
#define driver2R2 vexRT[Btn6UXmtr2]

// TODO: Delete
// #define driver1BtnB joy1Btn(3)
// #define driver1BtnX joy1Btn(1)
// #define driver1BtnY joy1Btn(4)
// #define driver1BtnL1 joy1Btn(5)
// #define driver1BtnR1 joy1Btn(6)
// #define driver1BtnL2 joy1Btn(7)
// #define driver1BtnR2 joy1Btn(8)
//
// #define driver2BtnA joy2Btn(2)
// #define driver2BtnB joy2Btn(3)
// #define driver2BtnX joy2Btn(1)
// #define driver2BtnY joy2Btn(4)
// #define driver2BtnL1 joy2Btn(5)
// #define driver2BtnR1 joy2Btn(6)
// #define driver2BtnL2 joy2Btn(7)
// #define driver2BtnR2 joy2Btn(8)
// #define driver2BtnBack joy2Btn(9)

// Library functions

int turnsToEncoders(const float turns) { return turns * 627.2; }
float encodersToTurns(const int encoders) { return encoders / 627.2; }

float joystickExponent(const float joystickValue)
{
	int motorValue;
    const int joystickZero = 5;
	const int minimumValue = 3; // This value high = less control, less whining; this value low = more fine control, more whining, more magic blue smoke (out of 100)
    const int backwards = joystickValue < 0 ? -1 : 1;
	if (abs(joystickValue) < joystickZero)
	{
		motorValue = 0;
	}
    else if (abs(joystickValue) > 127)
    {
        motorValue = 100 * backwards;
    }
	else
	{
		// We will play the piccolo
		const int motorMax = 127;
		motorValue = (pow(1.05, abs(joystickValue)) / pow(1.05, 127)
			* (motorMax - minimumValue) + minimumValue) * backwards;
	}
    return motorValue;
}

// TODO: Probably don't need
// void setX(const int power)
// {
//     motor[x1] = power;
//     motor[x2] = power;
// }
//
// void setY(const int power)
// {
//     motor[y1] = power;
//     motor[y2] = power;
// }
